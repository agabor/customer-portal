/**
 * Customer Point
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DefaultApi {

    protected basePath = 'http://customerpoint.net/api/v1';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * Login with email and password. The response contains a JWT. 
     * @param email 
     * @param password 
     */
    public loginPost(email: string, password: string, extraHttpRequestParams?: any): Observable<models.User> {
        return this.loginPostWithHttpInfo(email, password, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     */
    public logoutPost(extraHttpRequestParams?: any): Observable<{}> {
        return this.logoutPostWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * list of projects
     */
    public projectsGet(extraHttpRequestParams?: any): Observable<Array<models.ProjectBase>> {
        return this.projectsGetWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @param id project identifier
     */
    public projectsIdDelete(id: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.projectsIdDeleteWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * project data
     * @param id project identifier
     */
    public projectsIdGet(id: string, extraHttpRequestParams?: any): Observable<models.Project> {
        return this.projectsIdGetWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * delete image
     * @param id project identifier
     * @param imageId image identifier
     */
    public projectsIdImagesImageIdDelete(id: string, imageId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.projectsIdImagesImageIdDeleteWithHttpInfo(id, imageId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * modify image
     * @param id project identifier
     * @param imageId image identifier
     * @param name 
     * @param description 
     * @param minWidth 
     * @param maxWidth 
     * @param minHeight 
     * @param maxHeight 
     */
    public projectsIdImagesImageIdPatch(id: string, imageId: string, name?: string, description?: string, minWidth?: number, maxWidth?: number, minHeight?: number, maxHeight?: number, extraHttpRequestParams?: any): Observable<models.Image> {
        return this.projectsIdImagesImageIdPatchWithHttpInfo(id, imageId, name, description, minWidth, maxWidth, minHeight, maxHeight, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * update image
     * @param id project identifier
     * @param imageId image identifier
     * @param image The uploaded image
     */
    public projectsIdImagesImageIdPost(id: string, imageId: string, image: any, extraHttpRequestParams?: any): Observable<{}> {
        return this.projectsIdImagesImageIdPostWithHttpInfo(id, imageId, image, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * add image
     * @param id project identifier
     * @param name 
     * @param description 
     * @param minWidth 
     * @param maxWidth 
     * @param minHeight 
     * @param maxHeight 
     */
    public projectsIdImagesPatch(id: string, name?: string, description?: string, minWidth?: number, maxWidth?: number, minHeight?: number, maxHeight?: number, extraHttpRequestParams?: any): Observable<models.Image> {
        return this.projectsIdImagesPatchWithHttpInfo(id, name, description, minWidth, maxWidth, minHeight, maxHeight, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * remove language from project
     * @param id project identifier
     * @param code 
     */
    public projectsIdLanguagesDelete(id: string, code?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.projectsIdLanguagesDeleteWithHttpInfo(id, code, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * add language to project
     * @param id project identifier
     * @param code 
     */
    public projectsIdLanguagesPost(id: string, code?: string, extraHttpRequestParams?: any): Observable<models.Language> {
        return this.projectsIdLanguagesPostWithHttpInfo(id, code, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * delete link
     * @param id project identifier
     * @param linkId project identifier
     */
    public projectsIdLinksLinkIdDelete(id: string, linkId: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.projectsIdLinksLinkIdDeleteWithHttpInfo(id, linkId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * modify user
     * @param id project identifier
     * @param linkId project identifier
     * @param name 
     * @param icon 
     * @param url 
     */
    public projectsIdLinksLinkIdPost(id: string, linkId: number, name: string, icon: string, url: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.projectsIdLinksLinkIdPostWithHttpInfo(id, linkId, name, icon, url, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * create new user and add to project
     * @param id project identifier
     * @param name 
     * @param icon 
     * @param url 
     */
    public projectsIdLinksPost(id: string, name: string, icon: string, url: string, extraHttpRequestParams?: any): Observable<models.Link> {
        return this.projectsIdLinksPostWithHttpInfo(id, name, icon, url, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * update links
     * @param id project identifier
     * @param body 
     */
    public projectsIdLinksPut(id: string, body?: models.Body, extraHttpRequestParams?: any): Observable<{}> {
        return this.projectsIdLinksPutWithHttpInfo(id, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * modify project
     * @param id project identifier
     * @param name project name
     */
    public projectsIdPost(id: string, name: string, extraHttpRequestParams?: any): Observable<models.ProjectBase> {
        return this.projectsIdPostWithHttpInfo(id, name, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * add new text
     * @param id project identifier
     * @param textId 
     * @param name 
     * @param description 
     * @param startGroup 
     * @param minLength 
     * @param maxLength 
     */
    public projectsIdTextsPost(id: string, textId: string, name: string, description: string, startGroup: string, minLength: number, maxLength: number, extraHttpRequestParams?: any): Observable<models.Text> {
        return this.projectsIdTextsPostWithHttpInfo(id, textId, name, description, startGroup, minLength, maxLength, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * update texts
     * @param id project identifier
     * @param body 
     */
    public projectsIdTextsPut(id: string, body?: models.Body1, extraHttpRequestParams?: any): Observable<{}> {
        return this.projectsIdTextsPutWithHttpInfo(id, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * delete text
     * @param id project identifier
     * @param textId 
     */
    public projectsIdTextsTextIdDelete(id: string, textId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.projectsIdTextsTextIdDeleteWithHttpInfo(id, textId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * modify text
     * @param id project identifier
     * @param textId 
     * @param name 
     * @param description 
     * @param startGroup 
     * @param minLength 
     * @param maxLength 
     */
    public projectsIdTextsTextIdPost(id: string, textId: string, name: string, description: string, startGroup: string, minLength: number, maxLength: number, extraHttpRequestParams?: any): Observable<models.Text> {
        return this.projectsIdTextsTextIdPostWithHttpInfo(id, textId, name, description, startGroup, minLength, maxLength, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * create new user and add to project
     * @param id project identifier
     * @param name 
     * @param email 
     */
    public projectsIdUsersPost(id: string, name: string, email: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.projectsIdUsersPostWithHttpInfo(id, name, email, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * delete user
     * @param id project identifier
     * @param userId project identifier
     */
    public projectsIdUsersUserIdDelete(id: string, userId: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.projectsIdUsersUserIdDeleteWithHttpInfo(id, userId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * modify user
     * @param id project identifier
     * @param userId project identifier
     * @param name 
     * @param email 
     */
    public projectsIdUsersUserIdPost(id: string, userId: number, name: string, email: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.projectsIdUsersUserIdPostWithHttpInfo(id, userId, name, email, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * add new project
     * @param name project name
     */
    public projectsPatch(name: string, extraHttpRequestParams?: any): Observable<models.Project> {
        return this.projectsPatchWithHttpInfo(name, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * sets the initial password for a user logged in with a token. 
     * @param password 
     */
    public setPasswordPost(password: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.setPasswordPostWithHttpInfo(password, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Login with username and password. The response contains a JWT. 
     * @param loginToken 
     */
    public tokenLoginTokenGet(loginToken: string, extraHttpRequestParams?: any): Observable<models.User> {
        return this.tokenLoginTokenGetWithHttpInfo(loginToken, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * 
     * Login with email and password. The response contains a JWT. 
     * @param email 
     * @param password 
     */
    public loginPostWithHttpInfo(email: string, password: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/login';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling loginPost.');
        }
        // verify required parameter 'password' is not null or undefined
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling loginPost.');
        }
        if (email !== undefined) {
            queryParameters.set('email', <any>email);
        }

        if (password !== undefined) {
            queryParameters.set('password', <any>password);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     */
    public logoutPostWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/logout';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * list of projects
     */
    public projectsGetWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id project identifier
     */
    public projectsIdDeleteWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdDelete.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * project data
     * @param id project identifier
     */
    public projectsIdGetWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdGet.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * delete image
     * @param id project identifier
     * @param imageId image identifier
     */
    public projectsIdImagesImageIdDeleteWithHttpInfo(id: string, imageId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/images/${imageId}'
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'imageId' + '}', String(imageId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdImagesImageIdDelete.');
        }
        // verify required parameter 'imageId' is not null or undefined
        if (imageId === null || imageId === undefined) {
            throw new Error('Required parameter imageId was null or undefined when calling projectsIdImagesImageIdDelete.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * modify image
     * @param id project identifier
     * @param imageId image identifier
     * @param name 
     * @param description 
     * @param minWidth 
     * @param maxWidth 
     * @param minHeight 
     * @param maxHeight 
     */
    public projectsIdImagesImageIdPatchWithHttpInfo(id: string, imageId: string, name?: string, description?: string, minWidth?: number, maxWidth?: number, minHeight?: number, maxHeight?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/images/${imageId}'
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'imageId' + '}', String(imageId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdImagesImageIdPatch.');
        }
        // verify required parameter 'imageId' is not null or undefined
        if (imageId === null || imageId === undefined) {
            throw new Error('Required parameter imageId was null or undefined when calling projectsIdImagesImageIdPatch.');
        }
        if (name !== undefined) {
            queryParameters.set('name', <any>name);
        }

        if (description !== undefined) {
            queryParameters.set('description', <any>description);
        }

        if (minWidth !== undefined) {
            queryParameters.set('minWidth', <any>minWidth);
        }

        if (maxWidth !== undefined) {
            queryParameters.set('maxWidth', <any>maxWidth);
        }

        if (minHeight !== undefined) {
            queryParameters.set('minHeight', <any>minHeight);
        }

        if (maxHeight !== undefined) {
            queryParameters.set('maxHeight', <any>maxHeight);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Patch,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * update image
     * @param id project identifier
     * @param imageId image identifier
     * @param image The uploaded image
     */
    public projectsIdImagesImageIdPostWithHttpInfo(id: string, imageId: string, image: any, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/images/${imageId}'
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'imageId' + '}', String(imageId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        let formParams = new FormData();

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdImagesImageIdPost.');
        }
        // verify required parameter 'imageId' is not null or undefined
        if (imageId === null || imageId === undefined) {
            throw new Error('Required parameter imageId was null or undefined when calling projectsIdImagesImageIdPost.');
        }
        // verify required parameter 'image' is not null or undefined
        if (image === null || image === undefined) {
            throw new Error('Required parameter image was null or undefined when calling projectsIdImagesImageIdPost.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'multipart/form-data'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        //headers.set('Content-Type', 'application/x-www-form-urlencoded');

        if (image !== undefined) {
            formParams.append('image', <any>image);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: formParams/*.toString()*/,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * add image
     * @param id project identifier
     * @param name 
     * @param description 
     * @param minWidth 
     * @param maxWidth 
     * @param minHeight 
     * @param maxHeight 
     */
    public projectsIdImagesPatchWithHttpInfo(id: string, name?: string, description?: string, minWidth?: number, maxWidth?: number, minHeight?: number, maxHeight?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/images'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdImagesPatch.');
        }
        if (name !== undefined) {
            queryParameters.set('name', <any>name);
        }

        if (description !== undefined) {
            queryParameters.set('description', <any>description);
        }

        if (minWidth !== undefined) {
            queryParameters.set('minWidth', <any>minWidth);
        }

        if (maxWidth !== undefined) {
            queryParameters.set('maxWidth', <any>maxWidth);
        }

        if (minHeight !== undefined) {
            queryParameters.set('minHeight', <any>minHeight);
        }

        if (maxHeight !== undefined) {
            queryParameters.set('maxHeight', <any>maxHeight);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Patch,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * remove language from project
     * @param id project identifier
     * @param code 
     */
    public projectsIdLanguagesDeleteWithHttpInfo(id: string, code?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/languages'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdLanguagesDelete.');
        }
        if (code !== undefined) {
            queryParameters.set('code', <any>code);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * add language to project
     * @param id project identifier
     * @param code 
     */
    public projectsIdLanguagesPostWithHttpInfo(id: string, code?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/languages'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdLanguagesPost.');
        }
        if (code !== undefined) {
            queryParameters.set('code', <any>code);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * delete link
     * @param id project identifier
     * @param linkId project identifier
     */
    public projectsIdLinksLinkIdDeleteWithHttpInfo(id: string, linkId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/links/${link_id}'
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'link_id' + '}', String(linkId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdLinksLinkIdDelete.');
        }
        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling projectsIdLinksLinkIdDelete.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * modify user
     * @param id project identifier
     * @param linkId project identifier
     * @param name 
     * @param icon 
     * @param url 
     */
    public projectsIdLinksLinkIdPostWithHttpInfo(id: string, linkId: number, name: string, icon: string, url: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/links/${link_id}'
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'link_id' + '}', String(linkId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdLinksLinkIdPost.');
        }
        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling projectsIdLinksLinkIdPost.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling projectsIdLinksLinkIdPost.');
        }
        // verify required parameter 'icon' is not null or undefined
        if (icon === null || icon === undefined) {
            throw new Error('Required parameter icon was null or undefined when calling projectsIdLinksLinkIdPost.');
        }
        // verify required parameter 'url' is not null or undefined
        if (url === null || url === undefined) {
            throw new Error('Required parameter url was null or undefined when calling projectsIdLinksLinkIdPost.');
        }
        if (name !== undefined) {
            queryParameters.set('name', <any>name);
        }

        if (icon !== undefined) {
            queryParameters.set('icon', <any>icon);
        }

        if (url !== undefined) {
            queryParameters.set('url', <any>url);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * create new user and add to project
     * @param id project identifier
     * @param name 
     * @param icon 
     * @param url 
     */
    public projectsIdLinksPostWithHttpInfo(id: string, name: string, icon: string, url: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/links'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdLinksPost.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling projectsIdLinksPost.');
        }
        // verify required parameter 'icon' is not null or undefined
        if (icon === null || icon === undefined) {
            throw new Error('Required parameter icon was null or undefined when calling projectsIdLinksPost.');
        }
        // verify required parameter 'url' is not null or undefined
        if (url === null || url === undefined) {
            throw new Error('Required parameter url was null or undefined when calling projectsIdLinksPost.');
        }
        if (name !== undefined) {
            queryParameters.set('name', <any>name);
        }

        if (icon !== undefined) {
            queryParameters.set('icon', <any>icon);
        }

        if (url !== undefined) {
            queryParameters.set('url', <any>url);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * update links
     * @param id project identifier
     * @param body 
     */
    public projectsIdLinksPutWithHttpInfo(id: string, body?: models.Body, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/links'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdLinksPut.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * modify project
     * @param id project identifier
     * @param name project name
     */
    public projectsIdPostWithHttpInfo(id: string, name: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdPost.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling projectsIdPost.');
        }
        if (name !== undefined) {
            queryParameters.set('name', <any>name);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * add new text
     * @param id project identifier
     * @param textId 
     * @param name 
     * @param description 
     * @param startGroup 
     * @param minLength 
     * @param maxLength 
     */
    public projectsIdTextsPostWithHttpInfo(id: string, textId: string, name: string, description: string, startGroup: string, minLength: number, maxLength: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/texts'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdTextsPost.');
        }
        // verify required parameter 'textId' is not null or undefined
        if (textId === null || textId === undefined) {
            throw new Error('Required parameter textId was null or undefined when calling projectsIdTextsPost.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling projectsIdTextsPost.');
        }
        // verify required parameter 'description' is not null or undefined
        if (description === null || description === undefined) {
            throw new Error('Required parameter description was null or undefined when calling projectsIdTextsPost.');
        }
        // verify required parameter 'startGroup' is not null or undefined
        if (startGroup === null || startGroup === undefined) {
            throw new Error('Required parameter startGroup was null or undefined when calling projectsIdTextsPost.');
        }
        // verify required parameter 'minLength' is not null or undefined
        if (minLength === null || minLength === undefined) {
            throw new Error('Required parameter minLength was null or undefined when calling projectsIdTextsPost.');
        }
        // verify required parameter 'maxLength' is not null or undefined
        if (maxLength === null || maxLength === undefined) {
            throw new Error('Required parameter maxLength was null or undefined when calling projectsIdTextsPost.');
        }
        if (textId !== undefined) {
            queryParameters.set('textId', <any>textId);
        }

        if (name !== undefined) {
            queryParameters.set('name', <any>name);
        }

        if (description !== undefined) {
            queryParameters.set('description', <any>description);
        }

        if (startGroup !== undefined) {
            queryParameters.set('startGroup', <any>startGroup);
        }

        if (minLength !== undefined) {
            queryParameters.set('minLength', <any>minLength);
        }

        if (maxLength !== undefined) {
            queryParameters.set('maxLength', <any>maxLength);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * update texts
     * @param id project identifier
     * @param body 
     */
    public projectsIdTextsPutWithHttpInfo(id: string, body?: models.Body1, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/texts'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdTextsPut.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * delete text
     * @param id project identifier
     * @param textId 
     */
    public projectsIdTextsTextIdDeleteWithHttpInfo(id: string, textId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/texts/${textId}'
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'textId' + '}', String(textId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdTextsTextIdDelete.');
        }
        // verify required parameter 'textId' is not null or undefined
        if (textId === null || textId === undefined) {
            throw new Error('Required parameter textId was null or undefined when calling projectsIdTextsTextIdDelete.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * modify text
     * @param id project identifier
     * @param textId 
     * @param name 
     * @param description 
     * @param startGroup 
     * @param minLength 
     * @param maxLength 
     */
    public projectsIdTextsTextIdPostWithHttpInfo(id: string, textId: string, name: string, description: string, startGroup: string, minLength: number, maxLength: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/texts/${textId}'
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'textId' + '}', String(textId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdTextsTextIdPost.');
        }
        // verify required parameter 'textId' is not null or undefined
        if (textId === null || textId === undefined) {
            throw new Error('Required parameter textId was null or undefined when calling projectsIdTextsTextIdPost.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling projectsIdTextsTextIdPost.');
        }
        // verify required parameter 'description' is not null or undefined
        if (description === null || description === undefined) {
            throw new Error('Required parameter description was null or undefined when calling projectsIdTextsTextIdPost.');
        }
        // verify required parameter 'startGroup' is not null or undefined
        if (startGroup === null || startGroup === undefined) {
            throw new Error('Required parameter startGroup was null or undefined when calling projectsIdTextsTextIdPost.');
        }
        // verify required parameter 'minLength' is not null or undefined
        if (minLength === null || minLength === undefined) {
            throw new Error('Required parameter minLength was null or undefined when calling projectsIdTextsTextIdPost.');
        }
        // verify required parameter 'maxLength' is not null or undefined
        if (maxLength === null || maxLength === undefined) {
            throw new Error('Required parameter maxLength was null or undefined when calling projectsIdTextsTextIdPost.');
        }
        if (name !== undefined) {
            queryParameters.set('name', <any>name);
        }

        if (description !== undefined) {
            queryParameters.set('description', <any>description);
        }

        if (startGroup !== undefined) {
            queryParameters.set('startGroup', <any>startGroup);
        }

        if (minLength !== undefined) {
            queryParameters.set('minLength', <any>minLength);
        }

        if (maxLength !== undefined) {
            queryParameters.set('maxLength', <any>maxLength);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * create new user and add to project
     * @param id project identifier
     * @param name 
     * @param email 
     */
    public projectsIdUsersPostWithHttpInfo(id: string, name: string, email: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/users'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdUsersPost.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling projectsIdUsersPost.');
        }
        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling projectsIdUsersPost.');
        }
        if (name !== undefined) {
            queryParameters.set('name', <any>name);
        }

        if (email !== undefined) {
            queryParameters.set('email', <any>email);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * delete user
     * @param id project identifier
     * @param userId project identifier
     */
    public projectsIdUsersUserIdDeleteWithHttpInfo(id: string, userId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/users/${user_id}'
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'user_id' + '}', String(userId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdUsersUserIdDelete.');
        }
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling projectsIdUsersUserIdDelete.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * modify user
     * @param id project identifier
     * @param userId project identifier
     * @param name 
     * @param email 
     */
    public projectsIdUsersUserIdPostWithHttpInfo(id: string, userId: number, name: string, email: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects/${id}/users/${user_id}'
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'user_id' + '}', String(userId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling projectsIdUsersUserIdPost.');
        }
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling projectsIdUsersUserIdPost.');
        }
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling projectsIdUsersUserIdPost.');
        }
        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling projectsIdUsersUserIdPost.');
        }
        if (name !== undefined) {
            queryParameters.set('name', <any>name);
        }

        if (email !== undefined) {
            queryParameters.set('email', <any>email);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * add new project
     * @param name project name
     */
    public projectsPatchWithHttpInfo(name: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/projects';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling projectsPatch.');
        }
        if (name !== undefined) {
            queryParameters.set('name', <any>name);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Patch,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * sets the initial password for a user logged in with a token. 
     * @param password 
     */
    public setPasswordPostWithHttpInfo(password: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/setPassword';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'password' is not null or undefined
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling setPasswordPost.');
        }
        if (password !== undefined) {
            queryParameters.set('password', <any>password);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Login with username and password. The response contains a JWT. 
     * @param loginToken 
     */
    public tokenLoginTokenGetWithHttpInfo(loginToken: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/token/${login_token}'
                    .replace('${' + 'login_token' + '}', String(loginToken));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'loginToken' is not null or undefined
        if (loginToken === null || loginToken === undefined) {
            throw new Error('Required parameter loginToken was null or undefined when calling tokenLoginTokenGet.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
